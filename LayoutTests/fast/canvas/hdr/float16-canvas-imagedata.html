<!-- webkit-test-runner [ CanvasPixelFormatEnabled=true ] -->
<!DOCTYPE html>
<html>
<head>
<script src="../../../resources/js-test-pre.js"></script>
</head>
<body>
<script>
description("Tests that put/getImageData work with float16 canvas.");

var canvas = document.createElement("canvas");
canvas.width = 10;
canvas.height = 10;
var context = canvas.getContext("2d", { pixelFormat: "float16" });
var r = 0;
var g = 128;
var b = 255;
var a = 255;
// FIXME: Fill still only works in SRGB/uint8, adapt when extended/float16 support is available.
context.fillStyle = `rgb(${r} ${g} ${b})`;
context.fillRect(0, 0, 1, 1);

function shouldBeAround(to_eval, targetNumber, tolerance, quiet)
{
    if (!tolerance)
        return shouldBe(to_eval, String(targetNumber), quiet);
    return shouldBeCloseTo(to_eval, targetNumber, tolerance, quiet);
}

function verifyImageData(variable, constructor, bytesPerElement, red, green, blue, alpha, tolerance, quiet) {
    shouldBe(variable + '.width', '1', quiet);
    shouldBe(variable + '.height', '1', quiet);
    shouldBe(variable + '.data.constructor', constructor, quiet);
    shouldBe(variable + '.data.BYTES_PER_ELEMENT', String(bytesPerElement), quiet);
    shouldBe(variable + '.data.length', '4', quiet);
    shouldBe(variable + '.data.byteLength', String(bytesPerElement * 4), quiet);
    shouldBeAround(variable + '.data.at(0)', red, tolerance, quiet);
    shouldBeAround(variable + '.data.at(1)', green, tolerance, quiet);
    shouldBeAround(variable + '.data.at(2)', blue, tolerance, quiet);
    shouldBeAround(variable + '.data.at(3)', alpha, tolerance, quiet);
}

const uint8_bytes_per_element = 1;
const float16_bytes_per_element = 2;
// Less than half the range of a color component [0..255]/255 unit.
const float16_nonzero_tolerance = (1 / 256) / 2;

var created_imageData_float16 = context.createImageData(1, 1, { storageFormat: "float16" });
verifyImageData('created_imageData_float16', 'Float16Array', float16_bytes_per_element, 0, 0, 0, 0, 0);

var gotten_imageData_float16 = context.getImageData(0, 0, 1, 1, { storageFormat: "float16" });
verifyImageData('gotten_imageData_float16', 'Float16Array', float16_bytes_per_element, r / 255, g / 255, b / 255, a / 255, float16_nonzero_tolerance);

var created_imageData_uint8 = context.createImageData(1, 1, { storageFormat: "uint8" });
verifyImageData('created_imageData_uint8', 'Uint8ClampedArray', uint8_bytes_per_element, 0, 0, 0, 0);

// This verifies the basic float16->uint8 conversion:
var gotten_imageData_uint8 = context.getImageData(0, 0, 1, 1, { storageFormat: "uint8" });
verifyImageData('gotten_imageData_uint8', 'Uint8ClampedArray', uint8_bytes_per_element, r, g, b, a);

// Put the float16 ImageData back into the (uint8-backed) canvas, and get a default (uint8) ImageData.
// This verifies the basic uint8->float16 conversion.
context.clearRect(0, 0, 1, 1);
context.putImageData(gotten_imageData_float16, 0, 0);
var gotten_imageData_uint8_from_float16 = context.getImageData(0, 0, 1, 1);
verifyImageData('gotten_imageData_uint8_from_float16', 'Uint8ClampedArray', uint8_bytes_per_element, r, g, b, a);

// Exhaustive uint8->float16->uint8 round-trip test for all possible individual SRGB/uint8 component values. Only log errors.
const quiet = true;
for (let v = 0; v < 256; ++v) {
    for (component = 0; component < 4; ++component) {
        r = g = b = 0;
        a = 255;
        switch (component) {
        case 0: r = v; break;
        case 1: g = v; break;
        case 2: b = v; break;
        case 2: r = g = b = 255; a = v; break;
        }
        created_imageData_uint8.data[0] = r;
        created_imageData_uint8.data[1] = g;
        created_imageData_uint8.data[2] = b;
        created_imageData_uint8.data[3] = a;
        const prefix = '/* #' + v + "-" + component + ": " + r + "," + g + "," + b + "," + a + " */ ";

        context.putImageData(created_imageData_uint8, 0, 0);
        gotten_imageData_uint8 = context.getImageData(0, 0, 1, 1, { storageFormat: "uint8" });
        verifyImageData(prefix + 'gotten_imageData_uint8', 'Uint8ClampedArray', uint8_bytes_per_element, r, g, b, a, 0, quiet);
        gotten_imageData_float16 = context.getImageData(0, 0, 1, 1, { storageFormat: "float16" });
        verifyImageData(prefix + 'gotten_imageData_float16', 'Float16Array', float16_bytes_per_element, r / 255, g / 255, b / 255, a / 255, float16_nonzero_tolerance, quiet);

        context.clearRect(0, 0, 1, 1);
        context.putImageData(gotten_imageData_float16, 0, 0);
        gotten_imageData_float16 = context.getImageData(0, 0, 1, 1, { storageFormat: "float16" });
        verifyImageData(prefix + 'gotten_imageData_float16', 'Float16Array', float16_bytes_per_element, r / 255, g / 255, b / 255, a / 255, float16_nonzero_tolerance, quiet);
        gotten_imageData_uint8 = context.getImageData(0, 0, 1, 1, { storageFormat: "uint8" });
        verifyImageData(prefix + 'gotten_imageData_uint8', 'Uint8ClampedArray', uint8_bytes_per_element, r, g, b, a, 0, quiet);
    }
}

// Deeper float16->(same)float16->uint8->(nearby)float16 round-trip test for many possible individual component values. Only log errors.
const divisions = 512;
const maxValue = 2;
// A few extras:      largest subnormal    smallest normal  largest <1     smallest >1  largest ...
const extraValues = [ 6.097555160522461e-5, 6.103515625e-5, 0.99951171875, 1.0009765625, 65504, -1, -65504, Infinity, -Infinity ];
for (let division = -extraValues.length; division < divisions; ++division) {
    const floatValue = (division >= 0) ? (maxValue * division / divisions) : extraValues[extraValues.length + division];
    for (component = 0; component < 3; ++component) {
        r = g = b = 0;
        a = 1;
        switch (component) {
        case 0: r = floatValue; break;
        case 1: g = floatValue; break;
        case 2: b = floatValue; break;
        }
        created_imageData_float16.data[0] = r;
        created_imageData_float16.data[1] = g;
        created_imageData_float16.data[2] = b;
        created_imageData_float16.data[3] = a;
        const prefix = '/* #' + ((division >= 0) ? division : ((extraValues.length + division) + "extra")) + "-" + component + ": " + r + "," + g + "," + b + "," + a + " */ ";

        context.putImageData(created_imageData_float16, 0, 0);
        gotten_imageData_float16 = context.getImageData(0, 0, 1, 1, { storageFormat: "float16" });
        verifyImageData(prefix + 'gotten_imageData_float16', 'Float16Array', float16_bytes_per_element, r, g, b, a, 0, quiet);

        // Convert float16 [0,1] to expected [0,255] value, with a tolerance of half a unit.
        const uint8_nonzero_tolerance = 1 / 2;
        let clamp01 = (x) => Math.min(Math.max(x, 0), 1);
        r = clamp01(r) * 255;
        g = clamp01(g) * 255;
        b = clamp01(b) * 255;
        a = clamp01(a) * 255;
        gotten_imageData_uint8 = context.getImageData(0, 0, 1, 1, { storageFormat: "uint8" });
        verifyImageData(prefix + 'gotten_imageData_uint8', 'Uint8ClampedArray', uint8_bytes_per_element, r, g, b, a, uint8_nonzero_tolerance, quiet);

        // Convert rounded uint8 back to float.
        context.clearRect(0, 0, 1, 1);
        context.putImageData(gotten_imageData_uint8, 0, 0);
        r = Math.round(r);
        g = Math.round(g);
        b = Math.round(b);
        a = Math.round(a);
        gotten_imageData_uint8 = context.getImageData(0, 0, 1, 1, { storageFormat: "uint8" });
        verifyImageData(prefix + 'gotten_imageData_uint8', 'Uint8ClampedArray', uint8_bytes_per_element, r, g, b, a, 0, quiet);
        gotten_imageData_float16 = context.getImageData(0, 0, 1, 1, { storageFormat: "float16" });
        verifyImageData(prefix + 'gotten_imageData_float16', 'Float16Array', float16_bytes_per_element, r / 255, g / 255, b / 255, a / 255, float16_nonzero_tolerance, quiet);
    }
}

shouldThrowErrorName(`context.createImageData(1, 1, { storageFormat: "foo" })`, "TypeError")
shouldThrowErrorName(`context.getImageData(0, 0, 1, 1, { storageFormat: "foo" })`, "TypeError")
</script>
<script src="../../resources/js-test-post.js"></script>
</body>
</html>
